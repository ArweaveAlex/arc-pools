export declare const NFT_INIT_STATE: {
    title: string;
    name: string;
    description: string;
    ticker: string;
    balances: {};
    maxSupply: number;
    contentType: string;
    transferable: boolean;
    lockTime: number;
    lastTransferTimestamp: any;
};
export declare const NFT_CONTRACT_SRC = "\n\"use strict\";\nfunction handle(state, action) {\n    const input = action.input;\n    const caller = action.caller;\n    if (input.function === \"transfer\") {\n        ContractAssert(state.transferable ?? true, \"Token cannot be transferred - soulbound\");\n        const current = SmartWeave.block.timestamp;\n        if (state.lastTransferTimestamp && state.lockTime) {\n            ContractAssert((current - state.lastTransferTimestamp) <= state.lockTime, \"Token cannot be transferred - time-based soulbound\");\n        }\n        const target = input.target;\n        ContractAssert(target, \"No target specified.\");\n        ContractAssert(caller !== target, \"Invalid token transfer.\");\n        const qty = Number(input.qty) * Number(state.maxSupply);\n        ContractAssert(qty && qty > 0 && Number.isInteger(qty), \"No valid quantity specified.\");\n        const balances = state.balances;\n        ContractAssert(caller in balances && balances[caller] >= qty, \"Caller has insufficient funds\");\n        balances[caller] -= qty;\n        if (balances[caller] === 0) {\n            delete balances[caller];\n        }\n        if (!(target in balances)) {\n            balances[target] = 0;\n        }\n        balances[target] += qty;\n        state.balances = balances;\n        state.lastTransferTimestamp = current;\n        return { state };\n    }\n    if (input.function === \"balance\") {\n        let target;\n        if (input.target) {\n            target = input.target;\n        }\n        else {\n            target = caller;\n        }\n        const ticker = state.ticker;\n        const balances = state.balances;\n        ContractAssert(typeof target === \"string\", \"Must specify target to retrieve balance for.\");\n        return {\n            result: {\n                target,\n                ticker,\n                balance: target in balances ? balances[target] / state.maxSupply : 0,\n                intBalance: target in balances ? balances[target] : 0\n            }\n        };\n    }\n    throw new ContractError(\"No function supplied or function not recognised.\");\n}\n";
export declare const POOL_CONTRACT_SRC = "\n\"use strict\";\nfunction addOrUpdateBigStrings(object, key, qty) {\n    if (object[key]) {\n        object[key] = (BigInt(object[key]) + qty).toString();\n    }\n    else {\n        object[key] = qty.toString();\n    }\n}\nfunction updateContributions(object, key, qty) {\n    if (object[key]) {\n        object[key].push({\n            timestamp: Date.now().toString(), qty: BigInt(qty).toString()\n        });\n    }\n    else {\n        object[key] = [{ timestamp: Date.now().toString(), qty: qty.toString() }];\n    }\n}\nfunction addOrUpdateIntStrings(object, key, qty) {\n    if (object[key]) {\n        object[key] = (parseInt(object[key]) + qty).toString();\n    }\n    else {\n        object[key] = qty.toString();\n    }\n}\nasync function handle(state, action) {\n    const caller = action.caller;\n    const canEvolve = state.canEvolve;\n    switch (action.input.function) {\n        case \"contribute\": {\n            const contribution = BigInt(SmartWeave.transaction.quantity);\n            const target = SmartWeave.transaction.target;\n            const totalSupply = parseInt(state.totalSupply);\n            const totalContributions = BigInt(state.totalContributions);\n            // check inputs\n            if ((target !== state.owner) && (target !== state.controlPubkey)) {\n                throw new ContractError(\"Please fund the correct owner or controller.\");\n            }\n            if (contribution == BigInt(0)) {\n                throw new ContractError(\"Please fund a non-zero amount\");\n            }\n            if (totalContributions == BigInt(0)) {\n                // mint 100% of supply\n                state.tokens = {};\n                state.tokens[caller] = state.totalSupply.toString();\n                updateContributions(state.contributors, action.caller, contribution);\n                state.totalContributions = (totalContributions + contribution).toString();\n            }\n            else {\n                // calculate new mints\n                const mintedTokens = (Number(BigInt(1000000000000) * contribution / totalContributions) / 1000000000000) * Number(totalSupply);\n                const adjustmentFactor = Number(totalSupply) / Number(totalSupply + mintedTokens);\n                let sum = 0;\n                for (const key in state.tokens) {\n                    const newAlloc = state.tokens[key] * adjustmentFactor;\n                    sum += newAlloc;\n                    state.tokens[key] = newAlloc.toString();\n                }\n                addOrUpdateBigStrings(state, \"balance\", contribution);\n                addOrUpdateIntStrings(state.tokens, action.caller, totalSupply - sum);\n                updateContributions(state.contributors, action.caller, contribution);\n                state.totalContributions = (totalContributions + contribution).toString();\n            }\n            return { state };\n        }\n        case \"setTopics\": {\n            if (state.owner !== caller) {\n                throw new ContractError('Only the owner can add topics.');\n            }\n        \n            // set topic values to input list\n            state.topics = action.input.data;\n        \n            return { state };\n        }\n        case \"evolve\": {\n            if (canEvolve) {\n                if (state.owner !== caller) {\n                  throw new ContractError('Only the owner can evolve a contract.');\n                }\n            \n                state.evolve = action.input.value;\n            \n                return { state };\n            }\n        }\n        default: {\n            throw new ContractError(\"No action \" + action.input.function + \" exists. Please send a valid action.\");\n        }\n    }\n}\n";
